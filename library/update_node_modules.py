def update_node_modules():
    node_modules.clear()
    import_root = get_import_root()
    debug("update_node_modules: import_root", import_root)
    loading_modules = {}
    interval = 4

    def load_module_timer():
        nonlocal loading_modules
        is_loading = len(loading_modules) > 0
        debug("load_module_timer: loading_modules", loading_modules)
        if is_loading:
            loading_count = 0
            loading_names = []
            for key, value in loading_modules.items():
                loading_modules[key] = value + 1
                loading_names.append(key)
                loading_count += loading_modules[key]
            message_names = " and ".join(loading_names)
            message = "{0}: Processing {1}... {2}".format(
                PROJECT_NAME, message_names, interval * loading_count
            )
            sublime.status_message(message)
            sublime.set_timeout(load_module_timer, interval * 1000)

    def load_module(name):
        nonlocal loading_modules
        loading_modules.update({name: 0})
        result = run_command("get_module", {"importRoot": import_root, "name": name})
        get_modules_callback(None, result, {"name": name, "count": len(result)})
        loading_modules.pop(name)

    def get_from_package_callback(err, result):
        nonlocal loading_modules
        if err:
            sublime.error_message("{0}:\n{1}".format(PROJECT_NAME, str(err)))
            return
        if type(result) is not list:
            sublime.error_message(
                "{0}:\nUnexpected type of result: {1}".format(
                    PROJECT_NAME, type(result)
                )
            )
            return
        node_modules_names = set(())
        for name in result:
            if type(name) == str and len(name) > 0:
                node_modules_names.add(name)
        debug("get_from_package_callback: node_modules_names", node_modules_names)
        for name in node_modules_names:
            node_modules.append(
                {"module": name, "name": name, "isDefault": True, "from_package": True}
            )
        sublime.set_timeout(load_module_timer, interval)
        with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
            futures = [
                executor.submit(load_module, name) for name in node_modules_names
            ]
            concurrent.futures.wait(
                futures, timeout=None, return_when=concurrent.futures.ALL_COMPLETED
            )
            # future_to_name = {executor.submit(load_module, name): name for name in node_modules_names}
            loading_modules.clear()
            debug("Processing node modules is stopped")

    run_command_async(
        "get_from_package", {"importRoot": import_root}, get_from_package_callback
    )
